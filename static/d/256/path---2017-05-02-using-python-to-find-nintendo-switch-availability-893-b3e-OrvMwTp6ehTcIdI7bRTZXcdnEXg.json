{"data":{"markdownRemark":{"html":"<p>This isn't super relevant with the increased Nintendo Switch availability, but I thought I'd document the process I used to make an automated in-stock notifier for Target. The main point about talking about this is how you can make a pretty useful tool with a couple lines of Python.</p>\n<h3>Grabbing the data</h3>\n<p>I started out this project expecting to have to scrape the HTML from the availability page on Target.com. Doing this would require grabbing the page using something like <code>urllib.urlopen</code> and then parsing the HTML using something like <code>lxml</code> or <code>BeautifulSoup</code> and then using a CSS selector to find the fields of interest in the document. However, if you open up the network tab and filter by XHR requests, you can see that the webpage does a request to <a href=\"https://api.target.com\">api.target.com</a>, which returns a JSON document of which stores have stock in the area around your zipcode.</p>\n<p><img src=\"https://devopps.me/static/network_tab.png\" alt=\"network tab\"></p>\n<p>Now that we know there's a working API endpoint, we don't need to use extra modules like <code>lxml</code> or <code>BeautifulSoup</code> to parse HTML. We can parse the data using the <code>json</code> module and <code>json.loads</code>. This portion of the JSON document looks promising.</p>\n<pre><code class=\"language-json\">\"locations\": [\n        {\n          \"location_id\": \"2759\",\n          \"location_type\": \"STORE\",\n          \"distance\": \"0.00\",\n          \"store_name\": \"San Luis Obispo\",\n          \"store_address\": \"11990 LOS OSOS VALLEY RD San Luis Obispo CA 93405\",\n          \"formatted_store_address\": \"11990 LOS OSOS VALLEY RD, San Luis Obispo, CA 93405\",\n          \"store_main_phone\": \"805-858-9902\",\n          \"location_available_to_promise_quantity\": 0,\n          \"location_available_to_release_quantity\": 0,\n          \"inventory_type\": \"STORES\",\n          \"onhand_quantity\": 0,\n          \"location_demand_sum\": 0,\n          \"location_soft_demand_sum\": 0,\n          \"location_hard_demand_sum\": 0,\n          \"location_transfer_demand_sum\": 0,\n          \"location_supply_adjustment_sum\": 0,\n          \"product_location_threshold_quantity\": 0,\n          \"product_location_pickup_walkin_reserve\": 200,\n          \"availability_status\": \"OUT_OF_STOCK\",\n          \"multichannel_options\": [\n            \"HOLD\",\n            \"SHIPGUEST\",\n            \"SHIPSTORE\"\n          ]\n        },\n        ...\n    ]\n</code></pre>\n<p>We have a list named <strong>Locations</strong> that contains a <strong>store_name</strong> which is named after the city, and an <strong>availability_status</strong>, which is currently <strong>\"OUT<em>OF</em>STOCK\"</strong>. Hey, that's pretty good.</p>\n<p>Using the information we have so far, we can write a python script that looks a little like:</p>\n<pre><code class=\"language-python\">import urllib.request\nimport json\n\nclass Target:\n    api_url = \"Target API URL goes here\"\n    user_agent = \"Target doesn't like the default urllib User-Agent, so make you're own\"\n\n    def get_location_availability(self):\n        ''' Gets the in store availability for a grey switch near your zipcode\n            This takes the JSON response and loads it into a python dictionary and\n            returns the relevant 'locations' field.\n        '''\n        req = urllib.request.Request(Target.api_url)\n        req.add_header('User-Agent', Target.user_agent)\n\n        with urllib.request.urlopen(req) as res:\n            json_data = json.loads(res.read().decode('utf-8'))\n            return json_data['products'][0]['locations']\n\n    def get_available_stores(self):\n        store_availabilities = self.get_location_availability()\n\n        # Filter out stores that have an availability of \"OUT_OF_STOCK\"\n        in_stock = list(filter(lambda store: store['availability_status'] != \"OUT_OF_STOCK\", store_availabilities))\n        # Map the list of store statuses to a list of store name strings\n        return list(map(lambda store: store['store_name'], in_stock))\n\nif __name__ == \"__main__\":\n    target = Target()\n\n    # At this point stores is a list of store names that are not OUT_OF_STOCK.\n    stores = target.get_available_stores()\n</code></pre>\n<h3>Handling Push Notifications</h3>\n<p>The main utility behind this is that it notifies you in realtime, so that you don't need to take time everyday to check product availability listings. You could use email, or twilio for sms, or a slack bot, or pushbullet, or whatever push notification service you feel like. I used pushbullet because it's pretty easy.</p>\n<p>To set up Pushbullet, create an account and go to <a href=\"https://www.pushbullet.com/#settings\">https://www.pushbullet.com/#settings</a> and create an API Access Token. Using this token you can send a push notification from the Python script.</p>\n<p>To install the Pushbullet, run <code>pip install pushbullet.py</code>.</p>\n<p>A really simple push notification script looks like:</p>\n<pre><code class=\"language-python\">from pushbullet import Pushbullet\n\npb_api_key = \"Your API Access Token\"\npb = Pushbullet(pb_api_key)\n\ntitle = \"Test\"\nmessage = \"hey wow\"\npb.push_note(title, msg)\n</code></pre>\n<p>If you have Pushbullet installed on your phone, you should get a notification with the title and text sent in the example script.</p>\n<p>Here's an updated version of the Target script with a new method for sending a list of store names that have a non <strong>OUT<em>OF</em>STOCK</strong> status.</p>\n<pre><code class=\"language-python\">import urllib.request\nimport json\nfrom pushbullet import Pushbullet\n\nclass Target:\n    api_url = \"Target API URL goes here\"\n    user_agent = \"Target doesn't like the default urllib User-Agent, so make you're own\"\n\n    def get_location_availability(self):\n        ''' Gets the in store availability for a grey switch near your zipcode\n            This takes the JSON response and loads it into a python dictionary and\n            returns the relevant 'locations' field.\n        '''\n        req = urllib.request.Request(Target.api_url)\n        req.add_header('User-Agent', Target.user_agent)\n\n        with urllib.request.urlopen(req) as res:\n            json_data = json.loads(res.read().decode('utf-8'))\n            return json_data['products'][0]['locations']\n\n    def get_available_stores(self):\n        store_availabilities = self.get_location_availability()\n\n        # Filter out stores that have an availability of \"OUT_OF_STOCK\"\n        in_stock = list(filter(lambda store: store['availability_status'] != \"OUT_OF_STOCK\", store_availabilities))\n        # Map the list of store statuses to a list of store name strings\n        return list(map(lambda store: store['store_name'], in_stock))\n\n# New Stuff\ndef push_notifications(stores):\n    # Don't send a notification if no stores have it in stock.\n    if not stores:\n        return\n    pb_api_key = \"Your API Access Token\"\n    pb = Pushbullet(pb_api_key)\n\n    title = \"Switch Checker\"\n    msg = \"Switches in stock at: \" + \",\".join(stores)\n\nif __name__ == \"__main__\":\n    target = Target()\n\n    # At this point stores is a list of store names that are not OUT_OF_STOCK.\n    stores = target.get_available_stores()\n    # Send a notification with the in stock store names.\n    push_notifications(stores)\n</code></pre>\n<p>At this point we've got a fully-functioning script! Woo.</p>\n<h3>Running the script periodically</h3>\n<p>So far there's nothing in the script that has it run automatically or at a certain interval. One option is to use Cron to run the script once a day in the morning.</p>\n<p>To edit your <strong>crontab</strong>, type <code>crontab -e</code> on a Unix-like machine. It'll open up an editor and you can put something like</p>\n<pre><code class=\"language-sh\">0 8 * * * /path/to/your/python/script\n</code></pre>\n<p>That'll run the script every morning at 8AM. You can also have the python script loop forever, but sleep for a day or an hour or so between iterations. That'd look something like.</p>\n<pre><code class=\"language-python\">from time import sleep\n\nif __name__ == \"__main__\":\n    target = Target()\n\n    while True:\n        # At this point stores is a list of store names that are not OUT_OF_STOCK.\n        stores = target.get_available_stores()\n        # Send a notification with the in stock store names.\n        push_notifications(stores)\n        # Sleep a day\n        sleep(86400)\n</code></pre>\n<p>Hopefully if you're still trying to get a Switch, this can help your search be a little less stressful. Thanks for reading. Also don't spam the Target API because you'll get rate-limited and it's not super nice.</p>","frontmatter":{"title":"Using Python/Pushbullet to find Nintendo Switch Availability"}}},"pageContext":{"slug":"/2017-05-02-using-python-to-find-nintendo-switch-availability/"}}