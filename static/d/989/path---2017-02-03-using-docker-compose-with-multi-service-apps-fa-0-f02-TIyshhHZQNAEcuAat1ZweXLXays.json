{"data":{"markdownRemark":{"html":"<h2>Inspiration</h2>\n<p>I recently got to set up a multi-service web app with <a href=\"https://docs.docker.com/compose/\">Docker Compose</a>. I found that Docker Compose handled most of the problems that I've ran across when trying to \"dockerize\" web apps that have multiple components. One example of that is <a href=\"https://github.com/ifixit/pulldasher\">Pulldasher</a>, a GitHub pull request dashboard written by iFixit. Pulldasher is made up of an Express (Node.js) application and a MySQL database. Making a container around the Express application seemed simple enough, but creating a setup such that I can have a MySQL container spin up and tear down in sync with the Pulldasher container seemed like something I would have to automate myself using a shell script.</p>\n<h2>Introduction to Docker Compose</h2>\n<h3>Up and Running</h3>\n<p>I wasn't aware of Docker Compose until I had to set up a <a href=\"https://callpower.org\">CallPower</a> instance for <a href=\"https://repair.org\">Repair.org</a>. CallPower is an open source service that lets advocacy groups help constituents contact each of their representatives at a State or Federal level. The service ties together data from the OpenStates API and Sunlight Foundation and uses Twilio to connect constituents with their representatives. CallPower includes a <code>Dockerfile</code> which lets you build a container around the main application, which is a Flask app. It also includes a lightweight <code>docker-compose.yml</code> file, which specifies a single service named <em>calltool</em>, along with how to build that service's Docker image, which ports to forward, and which environment varibles to start the service with. As is, the <code>docker-compose.yml</code> will build an image for you with the name <code>&#x3C;current-directory>_&#x3C;service-name></code>,  start a container from that image named <code>&#x3C;current-directory>_&#x3C;service-name>_1</code>, forward the container's port <code>5000</code> to your host machine's <code>5000</code> and start the Flask app with the environment variables given. This all happens by running <code>docker-compose up</code> in the same directory as the <code>docker-compose.yml</code> file. Pretty cool.</p>\n<p>Here's a copy of the example <code>docker-compose.yml</code> given with CallPower.</p>\n<pre><code class=\"language-conf\">version: '2'\n\nservices:\n  calltool:\n    build: .  # tells docker-compose where to look for the Dockerfile to build the calltool Docker image.\n    environment:        # Environment variables for the Flask app\n      FLASK_ENV: development # or development-expose or production\n      SUNLIGHT_API_KEY:\n      TWILIO_DEV_ACCOUNT_SID:\n      TWILIO_ACCOUNT_SID:\n      TWILIO_DEV_AUTH_TOKEN:\n      TWILIO_AUTH_TOKEN:\n      SECRET_KEY:\n      ADMIN_API_KEY:\n      CALLPOWER_CONFIG: call_server.config:DevelopmentConfig # or call_server.config:ProductionConfig\n      APP_HOST: 0.0.0.0\n    ports:\n      - \"5000:5000\"     # Map the container's port 5000 to the host's port 5000\n</code></pre>\n<h3>Going Full Container</h3>\n<p>While that's pretty neat for starters, Callpower requires a Redis server for caching and a SQL database for use with SQLAlchemy in the Flask app. Connection URLs for these servers can easily be passed to the <em>calltool</em> container through environment variables, so if you have a Redis and MySQL/Postgres/sqlite server somewhere on the internet or your LAN to connect to, that's all you need to get started. <em>However</em>, if you'd like to be able to set up everything the application needs on your own host, you'll need to add Redis and SQL database services to the <code>docker-compose.yml</code>.</p>\n<h4>MariaDB with Volumes</h4>\n<p>Callpower requires a SQL database to store Admin credentials, call campaign information, call statistics, and voice recordings to play in each campaign phone call. For this example, we'll add another service to the <code>docker-compose.yml</code> file to tie together with our calltool service defined previously. We'll need to specify a service name, Docker image, and list of environments variables to start the database with. For this example we'll use MariaDB/MySQL.</p>\n<pre><code class=\"language-conf\">version: '2'\n\nservices:\n  calltool:\n    build: .  # tells docker-compose where to look for the Dockerfile to build the calltool Docker image.\n    environment:        # Environment variables for the Flask app\n      FLASK_ENV: development # or development-expose or production\n      SUNLIGHT_API_KEY:\n      TWILIO_DEV_ACCOUNT_SID:\n      TWILIO_ACCOUNT_SID:\n      TWILIO_DEV_AUTH_TOKEN:\n      TWILIO_AUTH_TOKEN:\n      SECRET_KEY:\n      ADMIN_API_KEY:\n      CALLPOWER_CONFIG: call_server.config:DevelopmentConfig # or call_server.config:ProductionConfig\n      APP_HOST: 0.0.0.0\n    ports:\n      - \"5000:5000\"     # Map the container's port 5000 to the host's port 5000\n  db:\n    image: \"mariadb:latest\"     # Use the latest MariaDB Docker image\n    volumes:\n     - db_data:/var/lib/mysql   # Mount the db_data volume onto /var/lib/mysql\n    environment:                # Set the MySQL environment variables\n      MYSQL_ROOT_PASSWORD:\n      MYSQL_DATABASE:\n      MYSQL_USER:\n      MYSQL_PASSWORD:\nvolumes:\n  db_data:          # Define the db_data volume\n</code></pre>\n<p>There are a couple things of note in the new <code>docker-compose.yml</code> file.</p>\n<ul>\n<li><em>db</em> is defined as another service</li>\n<li><em>db</em> has an <em>image</em> attribute instead of a <em>build</em> attribute. This is because we can grab the default MariaDB image.</li>\n<li><em>db</em> has a <em>volumes</em> attribute that specifies that a <em>db_data</em> volume is mounted to <code>/var/lib/mysql</code> in the container</li>\n<li>There is a new top level attribute called <em>volumes</em>, which contains a simple volume called <em>db_data</em>.</li>\n</ul>\n<p>Now that we've defined a <em>db</em> service, it will be brought up and shut down whenever we run <code>docker-compose up/down</code>. Another very useful aspect is that the <em>calltool</em> service can contact the <em>db</em> service using the service name as a domain name. For example, if you defined a MySQL connection string to tell the Flask app where to find the MySQL database, you could give it <code>mysql://&#x3C;user>:&#x3C;pass>@db/&#x3C;db_name></code>. Through some DNS magic (probably DNS?), the <code>db</code> domain name will resolve to the container's IP address. Something else that's important when using a database is to make sure it's storage doesn't disappear when you shut it down. Without defining a volume, the filesystem used by the <em>db</em> service would be deleted on shutdown and all of your data would be gone. To specify that we long storage that exists outside of a container's lifespan, we add a <em>volume</em>. The volume configuration above is all you need to define a simple volume and mount it on your container when it starts up. If you'd like to see where that volume actually exists on your host filesystem, you can run <code>docker volume &#x3C;volume_name></code>. The volume name in this case should be <code>callpower_db_data</code>.</p>\n<p>The output should look like this:</p>\n<pre><code>[\n    {\n        \"Name\": \"callpower_db_data\",\n        \"Driver\": \"local\",\n        \"Mountpoint\": \"/var/lib/docker/volumes/callpower_db_data/_data\",\n        \"Labels\": null,\n        \"Scope\": \"local\"\n    }\n]\n</code></pre>\n<p>The filepath described in <code>Mountpoint</code> is where the volume exists outside of your container. At this point running <code>docker-compose.yml</code> will bring up the <code>callpower_calltool_1</code> container and the <code>callpower_db_1</code> container.</p>\n<h4>Redis</h4>\n<p>The last running service needed is <em>Redis</em>. For development purposes, you can add a service named <em>redis</em> with and <em>image</em> value of <code>redis:alpine</code> and your Flask application will be able to reach it at <code>redis://redis:6379</code>, without any further configuration. Just like with the <em>db</em> service, your Flask app will be able to reach this container over the network by the domain name <code>redis</code>. With this configuration, the container won't be exposed to the internet, but if you're planning on running this service anywhere other than your laptop you should take measures to secure it with a strong password.</p>\n<p>The final <code>docker-compose.yml</code> looks like:</p>\n<pre><code>version: '2'\n\nservices:\n  calltool:         # calltool is the container that runs the Flask application\n    build: .  # tells docker-compose where to look for the Dockerfile to build the calltool Docker image.\n    environment:        # Environment variables for the Flask app\n      FLASK_ENV: development # or development-expose or production\n      SUNLIGHT_API_KEY:\n      TWILIO_DEV_ACCOUNT_SID:\n      TWILIO_ACCOUNT_SID:\n      TWILIO_DEV_AUTH_TOKEN:\n      TWILIO_AUTH_TOKEN:\n      SECRET_KEY:\n      ADMIN_API_KEY:\n      CALLPOWER_CONFIG: call_server.config:DevelopmentConfig # or call_server.config:ProductionConfig\n      APP_HOST: 0.0.0.0\n    ports:\n      - \"5000:5000\"     # Map the container's port 5000 to the host's port 5000\n  redis:        # redis is the container that runs redis\n    image: \"redis:alpine\"\n  db:           # db is the container that runs MariaDB/MySQL\n    image: \"mariadb:latest\"     # Use the latest MariaDB Docker image\n    volumes:\n     - db_data:/var/lib/mysql   # Mount the db_data volume onto /var/lib/mysql\n    environment:                # Set the MySQL environment variables\n      MYSQL_ROOT_PASSWORD:\n      MYSQL_DATABASE:\n      MYSQL_USER:\n      MYSQL_PASSWORD:\nvolumes:\n  db_data:          # Define the db_data volume\n</code></pre>\n<p>Running <code>docker-compose up</code> should start three containers named <code>callpower_calltool_1</code>, <code>callpower_redis_1</code>, and <code>callpower_db_1</code>. Running <code>docker-compose down</code> will stop each of the containers.</p>\n<h3>Takeaways</h3>\n<p><code>docker-compose</code> is a pretty simple way of specifying and organizing multiple services under a single configuration. Since most of the web apps I work on have at least a backend application and SQL server component, I'm planning on using this to more easily do web development and testing on my laptop, without needing to stay connected to a development server in the cloud. I'll probably do a follow up to my <em>Dockerizing Pulldasher</em> post with a how-to Pulldasher setup with <code>docker-compose</code>.</p>","frontmatter":{"title":"Using Docker Compose with web apps"}}},"pageContext":{"slug":"/2017-02-03-using-docker-compose-with-multi-service-apps/"}}